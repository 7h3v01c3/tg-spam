// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"sync"
)

// SpamFilterMock is a mock implementation of webapi.SpamFilter.
//
//	func TestSomethingThatUsesSpamFilter(t *testing.T) {
//
//		// make and configure a mocked webapi.SpamFilter
//		mockedSpamFilter := &SpamFilterMock{
//			DynamicSamplesFunc: func() ([]string, []string, error) {
//				panic("mock out the DynamicSamples method")
//			},
//			ReloadSamplesFunc: func() error {
//				panic("mock out the ReloadSamples method")
//			},
//		}
//
//		// use mockedSpamFilter in code that requires webapi.SpamFilter
//		// and then make assertions.
//
//	}
type SpamFilterMock struct {
	// DynamicSamplesFunc mocks the DynamicSamples method.
	DynamicSamplesFunc func() ([]string, []string, error)

	// ReloadSamplesFunc mocks the ReloadSamples method.
	ReloadSamplesFunc func() error

	// calls tracks calls to the methods.
	calls struct {
		// DynamicSamples holds details about calls to the DynamicSamples method.
		DynamicSamples []struct {
		}
		// ReloadSamples holds details about calls to the ReloadSamples method.
		ReloadSamples []struct {
		}
	}
	lockDynamicSamples sync.RWMutex
	lockReloadSamples  sync.RWMutex
}

// DynamicSamples calls DynamicSamplesFunc.
func (mock *SpamFilterMock) DynamicSamples() ([]string, []string, error) {
	if mock.DynamicSamplesFunc == nil {
		panic("SpamFilterMock.DynamicSamplesFunc: method is nil but SpamFilter.DynamicSamples was just called")
	}
	callInfo := struct {
	}{}
	mock.lockDynamicSamples.Lock()
	mock.calls.DynamicSamples = append(mock.calls.DynamicSamples, callInfo)
	mock.lockDynamicSamples.Unlock()
	return mock.DynamicSamplesFunc()
}

// DynamicSamplesCalls gets all the calls that were made to DynamicSamples.
// Check the length with:
//
//	len(mockedSpamFilter.DynamicSamplesCalls())
func (mock *SpamFilterMock) DynamicSamplesCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockDynamicSamples.RLock()
	calls = mock.calls.DynamicSamples
	mock.lockDynamicSamples.RUnlock()
	return calls
}

// ResetDynamicSamplesCalls reset all the calls that were made to DynamicSamples.
func (mock *SpamFilterMock) ResetDynamicSamplesCalls() {
	mock.lockDynamicSamples.Lock()
	mock.calls.DynamicSamples = nil
	mock.lockDynamicSamples.Unlock()
}

// ReloadSamples calls ReloadSamplesFunc.
func (mock *SpamFilterMock) ReloadSamples() error {
	if mock.ReloadSamplesFunc == nil {
		panic("SpamFilterMock.ReloadSamplesFunc: method is nil but SpamFilter.ReloadSamples was just called")
	}
	callInfo := struct {
	}{}
	mock.lockReloadSamples.Lock()
	mock.calls.ReloadSamples = append(mock.calls.ReloadSamples, callInfo)
	mock.lockReloadSamples.Unlock()
	return mock.ReloadSamplesFunc()
}

// ReloadSamplesCalls gets all the calls that were made to ReloadSamples.
// Check the length with:
//
//	len(mockedSpamFilter.ReloadSamplesCalls())
func (mock *SpamFilterMock) ReloadSamplesCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockReloadSamples.RLock()
	calls = mock.calls.ReloadSamples
	mock.lockReloadSamples.RUnlock()
	return calls
}

// ResetReloadSamplesCalls reset all the calls that were made to ReloadSamples.
func (mock *SpamFilterMock) ResetReloadSamplesCalls() {
	mock.lockReloadSamples.Lock()
	mock.calls.ReloadSamples = nil
	mock.lockReloadSamples.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *SpamFilterMock) ResetCalls() {
	mock.lockDynamicSamples.Lock()
	mock.calls.DynamicSamples = nil
	mock.lockDynamicSamples.Unlock()

	mock.lockReloadSamples.Lock()
	mock.calls.ReloadSamples = nil
	mock.lockReloadSamples.Unlock()
}
