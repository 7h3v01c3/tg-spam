// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"sync"
	"time"
)

// ApprovedUsersStoreMock is a mock implementation of webapi.ApprovedUsersStore.
//
//	func TestSomethingThatUsesApprovedUsersStore(t *testing.T) {
//
//		// make and configure a mocked webapi.ApprovedUsersStore
//		mockedApprovedUsersStore := &ApprovedUsersStoreMock{
//			StoreFunc: func(ids []string) error {
//				panic("mock out the Store method")
//			},
//			TimestampFunc: func(id string) (time.Time, error) {
//				panic("mock out the Timestamp method")
//			},
//		}
//
//		// use mockedApprovedUsersStore in code that requires webapi.ApprovedUsersStore
//		// and then make assertions.
//
//	}
type ApprovedUsersStoreMock struct {
	// StoreFunc mocks the Store method.
	StoreFunc func(ids []string) error

	// TimestampFunc mocks the Timestamp method.
	TimestampFunc func(id string) (time.Time, error)

	// calls tracks calls to the methods.
	calls struct {
		// Store holds details about calls to the Store method.
		Store []struct {
			// Ids is the ids argument value.
			Ids []string
		}
		// Timestamp holds details about calls to the Timestamp method.
		Timestamp []struct {
			// ID is the id argument value.
			ID string
		}
	}
	lockStore     sync.RWMutex
	lockTimestamp sync.RWMutex
}

// Store calls StoreFunc.
func (mock *ApprovedUsersStoreMock) Store(ids []string) error {
	if mock.StoreFunc == nil {
		panic("ApprovedUsersStoreMock.StoreFunc: method is nil but ApprovedUsersStore.Store was just called")
	}
	callInfo := struct {
		Ids []string
	}{
		Ids: ids,
	}
	mock.lockStore.Lock()
	mock.calls.Store = append(mock.calls.Store, callInfo)
	mock.lockStore.Unlock()
	return mock.StoreFunc(ids)
}

// StoreCalls gets all the calls that were made to Store.
// Check the length with:
//
//	len(mockedApprovedUsersStore.StoreCalls())
func (mock *ApprovedUsersStoreMock) StoreCalls() []struct {
	Ids []string
} {
	var calls []struct {
		Ids []string
	}
	mock.lockStore.RLock()
	calls = mock.calls.Store
	mock.lockStore.RUnlock()
	return calls
}

// ResetStoreCalls reset all the calls that were made to Store.
func (mock *ApprovedUsersStoreMock) ResetStoreCalls() {
	mock.lockStore.Lock()
	mock.calls.Store = nil
	mock.lockStore.Unlock()
}

// Timestamp calls TimestampFunc.
func (mock *ApprovedUsersStoreMock) Timestamp(id string) (time.Time, error) {
	if mock.TimestampFunc == nil {
		panic("ApprovedUsersStoreMock.TimestampFunc: method is nil but ApprovedUsersStore.Timestamp was just called")
	}
	callInfo := struct {
		ID string
	}{
		ID: id,
	}
	mock.lockTimestamp.Lock()
	mock.calls.Timestamp = append(mock.calls.Timestamp, callInfo)
	mock.lockTimestamp.Unlock()
	return mock.TimestampFunc(id)
}

// TimestampCalls gets all the calls that were made to Timestamp.
// Check the length with:
//
//	len(mockedApprovedUsersStore.TimestampCalls())
func (mock *ApprovedUsersStoreMock) TimestampCalls() []struct {
	ID string
} {
	var calls []struct {
		ID string
	}
	mock.lockTimestamp.RLock()
	calls = mock.calls.Timestamp
	mock.lockTimestamp.RUnlock()
	return calls
}

// ResetTimestampCalls reset all the calls that were made to Timestamp.
func (mock *ApprovedUsersStoreMock) ResetTimestampCalls() {
	mock.lockTimestamp.Lock()
	mock.calls.Timestamp = nil
	mock.lockTimestamp.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *ApprovedUsersStoreMock) ResetCalls() {
	mock.lockStore.Lock()
	mock.calls.Store = nil
	mock.lockStore.Unlock()

	mock.lockTimestamp.Lock()
	mock.calls.Timestamp = nil
	mock.lockTimestamp.Unlock()
}
